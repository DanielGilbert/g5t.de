<!doctype html>
<html lang="en">
<head>
    <title>Santa Paravia en Fiumaccio in C# | g5t.de</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="description" content="An article about a very old game in a modern language.">
    <link rel="icon" href="./../../favicon.ico">
    <link rel="stylesheet" href="./index.css">
</head>
<body class="container">
    <header>
        <h1>g[ilber]t.de</h1>
        <nav>
            <ul>
                <li><a href="../../">Welcome</a></li>
                <li><a href="../../articles/">Articles</a></li>
                <li><a href="../../tools/">Tools</a></li>
                <li><a href="../../games/">Games</a></li>
            </ul>
        </nav>
        <figure><img src="./paravia.jpg" /><figcaption>A C# implementation of a very, very old game...</figcaption></figure>
    </header>
    <main>
        <h2>Santa Paravia en Fiumaccio in C#</h2>
        <x-article-metalines draft="draft" published="2025-07-09" updated="2025-07-10" author="Daniel Gilbert"></x-article-metalines>
        <h3>Entering the rabbit hole</h3>
        <p>Recently, I got into a rabbit hole of old city planning games. The very first I found was <a href="https://en.wikipedia.org/wiki/The_Sumerian_Game">The Sumerian Game</a>. Created by Mabel Addis in 1964, it was one of the earliest text-based strategy video games of land and resource management.</p>
        <p>Other games in the same vain are <a href="https://en.wikipedia.org/wiki/Hamurabi_(video_game)">Hamurabi (1968)</a>, <a href="https://en.wikipedia.org/wiki/Dukedom_(video_game)">Dukedom (1976)</a> and <a href="https://en.wikipedia.org/wiki/Dynasty_(computer_game)">Dynasty (1978)</a>.</p>
        <p>Nowadays, text-based games see some kind of renaissance, thanks to <a href="https://store.steampowered.com/app/659540/Warsim_The_Realm_of_Aslona/">Warsim</a> or <a href="https://store.steampowered.com/app/3273130/Roots_of_Harmony/">Roots of Harmony</a></p>
        <p>In this article, I will focus on <a href="https://en.wikipedia.org/wiki/Santa_Paravia_en_Fiumaccio">Santa Paravia en Fiumaccio</a>, a game located in the 15th century in italy. This game was created in 1978 by George Blank, and published in the December 1978 issue of <em>SoftSide</em> magazine for the TRS-80.</p>
        <p>Wikipedia says this about the game:</p>
        <blockquote>Based loosely on the text game Hamurabi, <em>Santa Paravia and Fiumaccio</em> was an early <a href="https://en.wikipedia.org/wiki/God_game">god game</a>. It combined '<a href="https://en.wikipedia.org/wiki/Guns_versus_butter_model">guns and butter</a>' economic tradeoffs with graphic development of a kingdom with buildings being constructed and shown on the screen as well as character development, shown as progressive promotions from baron to king.  <footer>
    <cite>â€” Wikipedia</cite>
  </footer></blockquote>
        <p>The goal of the game is to progress from <em>Lady</em> (or <em>Sir</em>) to <em>H.R.H Queen</em> (or <em>H.R.H King</em>), meanwhile defending attackers and distributing grain according to need and availablilty. You can (and should) by additional land, grain and can control taxes.</p>
        <p>A fellow called <em>Thomas Knox</em> <a href="https://web.archive.org/web/20141129011448/http://planet-source-code.com/vb/scripts/ShowCode.asp?txtCodeId=7183&lngWId=3">converted the original TRS-80 code to ANSI-C in 2003</a>. In his conversion, he skipped the map part of the original game. We will get to that when we take a look at the implementation.</p>
        <h3>Let's dive into the code</h3>
        <p><em>Note: If you are interested in the original TRS-80 listing, you will find it here: <a href="https://archive.org/details/softside-magazine-03/">SoftSide Magazine Issue 03 (Santa Parvia)</a></em></p>
        <p><em>The converted code can be found <a href="https://github.com/DanielGilbert/Paravia">at GitHub</a>.</em></p>
        <p>Let's unpack the main <em>Run()</em> method of the C# conversion.</p>
        <div class="code-block">
        <line-numbers>
            <syntax-highlight language="clike">public void Run()
{
    Randomizer = new Random();
    Console.WriteLine("Santa Paravia and Fiumaccio");
    Console.WriteLine();
    Console.WriteLine("Do you wish instructions (Y or N)?");
    string? response = Console.ReadLine();

    if (!String.IsNullOrWhiteSpace(response) && (response.ToLower()[0] == 'y'))
    {
        PrintInstructions();
    }

    Console.WriteLine("How many people want to play (1 to 6)?");
    response = Console.ReadLine();
    NumberOfPlayers = Convert.ToInt32(response);
    if (NumberOfPlayers < 1 || NumberOfPlayers > 6)
    {
        Console.WriteLine("Thanks for playing!");
        return;
    }

    Console.WriteLine("What will be the difficulty of this game:");
    Console.WriteLine("1. Apprentice");
    Console.WriteLine("2. Journeyman");
    Console.WriteLine("3. Master");
    Console.WriteLine("4. Grand Master");
    Console.WriteLine();
    Console.Write("Choose: ");
    gameLevel = Convert.ToInt32(Console.ReadLine());
    if (gameLevel < 1)
    {
        gameLevel = 1;
    }
    if (gameLevel > 4)
    {
        gameLevel = 4;
    }

    for(int i = 0; i < NumberOfPlayers; i++)
    {
        Console.WriteLine("Who is the ruler of {0}?", CityList[i]);
        string? rulersName = Console.ReadLine();

        if (String.IsNullOrWhiteSpace(rulersName))
        {
            i--;
            continue;
        }

        Console.WriteLine("Is {0} male or female (m or f)?", rulersName);
        string? gender = Console.ReadLine()?.ToLower() ?? "f";
        bool isMale = (gender[0] == 'm');
        Players.Add(new Player());
        InitializePlayer(Players[i], 1400, i, gameLevel, rulersName, isMale);
    }

    PlayGame(Players, NumberOfPlayers);
}               </syntax-highlight>
            </line-numbers>
        </div>
        <p>The game relies in parts on randomization. As such, it is no surprise that we need to initialize random functionality. From line <b>3</b>&nbsp;&dash;&nbsp;<b>12</b>, the game will setup the randomizer, greet the player and ask, if the player needs further instructions. If confirmed, the game calls <code>PrintInstructions()</code>.</p>
        <p>A computer back in the days was a highlight to everyone. They were rather expensive, so there was usually one computer for the entire family. As such, it is no wonder that you are able to play this game at the same terminal with more than 1 player. Lines <b>14</b>&nbsp;&dash;&nbsp;<b>21</b> handle the logic to request the amount of players that are currently in this session.</p>
        <p>Lines <b>23</b>&nbsp;&dash;&nbsp;<b>38</b> set up the difficulty level for this game. It offers four level of difficulty. The numeric value of difficulty is used in the progression calculation of the game, which we will see more of later on.</p>
        <p>Depending on the amount of players, lines <b>40</b>&nbsp;&dash;&nbsp;<b>56</b> loop several times and setup the list of players by asking for names and initializing the player. <code>InitializePlayer()</code> is used to set several variables to its' initial state. That are not all variables that belong to the <code>player</code> record, but it's already an impressive list:</p>
        <div class="code-block">
        <line-numbers>
            <syntax-highlight language="clike">public void InitializePlayer(Player player, int year,
    int city, int level, string name, bool maleOrFemale)
{
    player.Cathedral = 0;
    player.City = CityList[city];
    player.Clergy = 5;
    player.CustomsDuty = 25;
    player.Difficulty = level;
    player.GrainPrice = 25;
    player.GrainReserve = 5000;
    player.IncomeTax = 5;
    player.IsBankrupt = false;
    player.IsDead = false;
    player.InvadeMe = false;
    player.IWon = false;
    player.Justice = 2;
    player.Land = 10000;
    player.LandPrice = 10.0;
    player.MaleOrFemale = maleOrFemale;
    player.Marketplaces = 0;
    player.Merchants = 25;
    player.Mills = 0;
    player.Name = name;
    player.Nobles = 4;
    player.OldTitle = 1;
    player.Palace = 0;
    player.PublicWorks = 1.0;
    player.SalesTax = 10;
    player.Serfs = 2000;
    player.Soldiers = 25;
    player.TitleNum = 1;
    if (player.MaleOrFemale == true)
        player.Title = MaleTitles[0];
    else
        player.Title = FemaleTitles[0];
    if (city == 6)
        player.Title = "Baron";
    player.Treasury = 1000;
    player.WhichPlayer = city;
    player.Year = year;
    player.YearOfDeath = year + 20 + Random(35);
    return;

}               </syntax-highlight>
            </line-numbers>
        </div>
        <p><code>Random(35);</code> is another function that is used rather often in this game. It will provide a random integer between 0 and the supplied parameters, exclusively. In this case, we will receive an integer between 0 and 34.</p>
        <p>The game also predetermines your year of death by using the start year (that is always <em>1400</em>), adding <em>20</em> to it (so you will at least play 20 rounds), and then randomly give you the aforementioned 0 to 34 more extra rounds. Of course, you might be defeated by other events, but at some point, you will lose because you died.</p>
        <p>Back to the original code. The only thing that is left to do is to call <code>PlayGame()</code>:</p>
<div class="code-block">
        <line-numbers>
            <syntax-highlight language="clike">private void PlayGame(List&lt;Player&gt; players, int numberOfPlayers)
{
    bool AllDead, Winner;
    int WinningPlayer = 0;
    Player Baron;
    AllDead = false;
    Winner = false;
    Baron = new Player();
    InitializePlayer(Baron, 1400, 6, 4, "Peppone", true);

    while (AllDead is false && Winner is false)
    {
        for(int i = 0; i < NumberOfPlayers; i++)
        {
            if (!players[i].IsDead)
            {
                NewTurn(players[i], NumberOfPlayers, players, Baron);
            }
        }

        AllDead = true;

        for(int i = 0; i < NumberOfPlayers; i++)
        {
            if (AllDead && players[i].IsDead is false)
            {
                AllDead = false;
            }
        }

        for(int i = 0; i < NumberOfPlayers; i++)
        {
            if (players[i].IWon is true)
            {
                Winner = true;
                WinningPlayer = i;
            }
        }
    }

    if (AllDead is true)
    {
        Console.WriteLine("The game has ended.");
        return;
    }

    Console.WriteLine("Game Over. {0} {1} wins.", players[WinningPlayer].Title, players[WinningPlayer].Name);
}               </syntax-highlight>
            </line-numbers>
        </div>
        <p>In this method, the computer opponent is introduced, lines <b>8</b> and <b>9</b> initialize a <em>Baron</em> called "Peppone".</p>
        <p>Lines <b>11</b>&nbsp;&dash;&nbsp;<b>39</b> are running the main loop as long as at least one player is not dead, or none of the players has won the game. That loop triggers the <code>NewTurn()</code> method for each player in the game. The Baron never participates in these turns. It's only <em>job</em> in this game is to be the attacker if only one player is playing the game.</p>
<div class="code-block">
        <line-numbers>
            <syntax-highlight language="clike">private void NewTurn(Player player, int numberOfPlayers, List&lt;Player&gt; players, Player baron)
{
    GenerateHarvest(player);
    NewLandAndGrainPrices(player);
    BuySellGrain(player);
    ReleaseGrain(player);

    if (player.InvadeMe is true)
    {
        int i = 0;
        for(i = 0; i < NumberOfPlayers; i++)
        {
            if (i != player.WhichPlayer)
            {
                if (players[i].Soldiers > (player.Soldiers * 2.4))
                {
                    _ = AttackNeighbor(players[i], player);
                    i = 9;
                }
            }
        }

        if (i != 9)
        {
            _ = AttackNeighbor(baron, player);
        }

    }

    AdjustTax(player);
    DrawMap(player);
    StatePurchases(player, numberOfPlayers, players);
    _ = CheckNewTitle(player);

    player.Year++;
    if (player.Year == player.YearOfDeath)
    {
        ImDead(player);
    }

    if (player.TitleNum >= 7)
    {
        player.IWon = true;
    }
}               </syntax-highlight>
            </line-numbers>
        </div>
        <p>Finally, we are able to dive into the nooks and crannies of this game. Each turn, the game will run the following steps:</p>
        <ul>
            <li><code>GenerateHarvest()</code>: Calculate the harvest, the amount of rats and the grain reserve. Harvest and rats are randomized numbers.</li>
            <li><code>NewLandAndGrainPrices()</code>: Calculate the land prices, the grain reserve, the demand for grain and how many grain got eaten by the rats.</li>
            <li><code>BuySellGrain()</code>: Display the grain reserve, the grain demand, the price of grain, price of land and the amount of money owned to the player. Also, ask the player what they would like to do next: Buy land or grain, sell land or grain or move to the next step.</li>
            <li><code>ReleaseGrain()</code>: The player is asked how much grain they want to release to the serfs. The player must keep at least a reserve of 20%, and they have to give out at least 20% of the whole reserve.</li>
            <li>The loop from lines <b>8</b>&nbsp;&dash;&nbsp;<b>28</b> deals with the attack logic. The player object contains a flag, <code>InvadeMe</code>, which signals that the player is too weak to defend against an opponent, which will trigger the attack logic. This is where the baron comes in play, if you are a single player. Line <b>25</b> will launch the attack with the baron, if there is only one player.</li>
            <li><code>AdjustTax()</code>: As a player, you can adjust the customs duty, the sales tax, the wealth tax and the amount of justice. In this method, the game also calculates the revenue the player made and will seize any assets, if the player is bankrupt.</li>
            <li><code>DrawMap()</code>: In the original TRS-80 code, this draws a neat map that shows you how many buildings you have, and how much land you have in comparison to serfs.</li>
            <li><code>StatePurchases()</code>: Nowadays, one would refer to it as the <em>buy screen</em>. Here, you can buy a marketplace, a woolen mill, a palace (partially), a cathedral (partially) and convert serfs to soldiers.</li>
            <li><code>CheckNewTitle()</code>: This is the progression logic. Here, the game calculates the progression based on multiple values with a cap on each. We'll take a closer look later on.</li>
            <li><code>ImDead()</code>: Yes. It does, what it says. It will print a small memorian message, and also randomly pick a cause of death. If you made it past <em>1450</em>, the only cod will be "<em>of old age after a long reign.</em>", which is kinda neat, to be honest.</li>
        </ul>
        <h3>The four phases of the game</h3>
        <p>The original explanation for the game calls out four phases: <em>Harvest Phase</em>, <em>Tax Phase</em>, <em>Map Phase</em> and <em>Public Works Phase</em>. We will dive into each of the phases, referencing the code we just uncovered, and talk a bit about how the game does what (or what I think the game does - I might not have fully understood everything).</p>
        <h4>Harvest Phase</h4>
        <p>The functions involved in this phase are the following:</p>
        <ul>
            <li><code>GenerateHarvest()</code></li>
            <li><code>NewLandAndGrainPrices()</code></li>
            <li><code>BuySellGrain()</code></li>
            <li><code>ReleaseGrain()</code></li>
        </ul>
        <h4>Tax Phase</h4>
        <h4>Map Phase</h4>
        <h4>Public Works Phase</h4>
    </main>
    <footer>
    <x-website-footer></x-website-footer>
    </footer>
    <script type="module" src="./index.js"></script>
</body>
</html>